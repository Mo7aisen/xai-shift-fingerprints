#!/usr/bin/env python
"""Summarise divergence metrics and generate quick plots."""

from __future__ import annotations

import argparse
import sys
from pathlib import Path
from typing import Any, Dict, List

import pandas as pd

try:
    import plotly.express as px
except Exception:  # pragma: no cover - plotting is optional
    px = None  # type: ignore

try:
    import matplotlib.pyplot as plt
except Exception:  # pragma: no cover - static plotting optional
    plt = None  # type: ignore


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Create markdown/plots summarising attribution divergence tables."
    )
    parser.add_argument(
        "--divergence-table",
        default="divergence_comparison_table.csv",
        help="CSV containing aggregate divergence metrics.",
    )
    parser.add_argument(
        "--detailed-table",
        default="detailed_metrics_comparison.csv",
        help="CSV containing per-dataset summary metrics.",
    )
    parser.add_argument(
        "--uncertainty-table",
        default="reports/divergence/divergence_uncertainty.csv",
        help="Optional CSV with bootstrap confidence intervals.",
    )
    parser.add_argument(
        "--output-dir",
        default="reports/divergence",
        help="Directory to write markdown and figures.",
    )
    parser.add_argument(
        "--plots",
        action="store_true",
        help="Generate Plotly bar charts (requires plotly).",
    )
    return parser.parse_args()


def load_csv(path: Path) -> pd.DataFrame:
    if not path.exists():
        raise FileNotFoundError(f"Expected CSV not found: {path}")
    return pd.read_csv(path)


def summarise_divergence(df: pd.DataFrame) -> Dict[str, Any]:
    df_sorted = df.sort_values(by="KL Divergence", ascending=False)
    if df_sorted.empty:
        raise ValueError("Divergence table is empty; ensure comparison CSV contains at least one row.")
    headline = df_sorted[["Comparison", "KL Divergence", "EMD", "Graph Edit Distance"]]
    top_shift = df_sorted.iloc[0]
    bottom_shift = df_sorted.iloc[-1]
    summary = {
        "table": headline,
        "count": int(len(df_sorted)),
        "max_shift": {
            "comparison": top_shift["Comparison"],
            "kl": float(top_shift["KL Divergence"]),
            "emd": float(top_shift["EMD"]),
            "graph": float(top_shift["Graph Edit Distance"]),
        },
        "min_shift": {
            "comparison": bottom_shift["Comparison"],
            "kl": float(bottom_shift["KL Divergence"]),
            "emd": float(bottom_shift["EMD"]),
            "graph": float(bottom_shift["Graph Edit Distance"]),
        },
    }
    return summary


def write_markdown(
    summary: Dict[str, Any],
    detailed: pd.DataFrame,
    divergence_path: Path,
    uncertainty: pd.DataFrame | None,
) -> str:
    headline_md = summary["table"].to_markdown(index=False)
    detailed_md = detailed.to_markdown(index=False)
    md = [
        "# Attribution Divergence Summary",
        "",
        f"Source: `{divergence_path}`",
        "",
        "## Headline KL / EMD / Graph Distances",
        "",
        headline_md,
        "",
        "### Key Highlights",
        "",
    ]
    if summary["count"] == 1:
        md.extend(
            [
                f"- Reported shift: **{summary['max_shift']['comparison']}** "
                f"(KL={summary['max_shift']['kl']:.4f}, EMD={summary['max_shift']['emd']:.4f}, "
                f"GED={summary['max_shift']['graph']:.4f})",
                "",
            ]
        )
    else:
        md.extend(
            [
                f"- Largest shift: **{summary['max_shift']['comparison']}** "
                f"(KL={summary['max_shift']['kl']:.4f}, EMD={summary['max_shift']['emd']:.4f}, "
                f"GED={summary['max_shift']['graph']:.4f})",
                f"- Smallest shift: **{summary['min_shift']['comparison']}** "
                f"(KL={summary['min_shift']['kl']:.4f}, EMD={summary['min_shift']['emd']:.4f}, "
                f"GED={summary['min_shift']['graph']:.4f})",
                "",
            ]
        )
    md.extend(
        [
            "## Dataset Metrics",
            "",
            detailed_md,
            "",
        ]
    )
    if uncertainty is not None and not uncertainty.empty:
        uncertainty_md = uncertainty.to_markdown(index=False)
        md.extend(
            [
                "## Bootstrapped 95% Confidence Intervals",
                "",
                uncertainty_md,
                "",
            ]
        )
    md.extend(
        [
            "> Generated by `scripts/analyze_divergence.py`",
            "",
        ]
    )
    return "\n".join(md)


def create_plots(df: pd.DataFrame, output_dir: Path) -> List[Path]:
    if px is None:
        return []
    figures: List[tuple[str, Any]] = []
    figures.append(
        (
            "kl_divergence.html",
            px.bar(
                df,
                x="Comparison",
                y="KL Divergence",
                title="KL Divergence per Comparison",
                text="KL Divergence",
            ),
        )
    )
    figures.append(
        (
            "emd.html",
            px.bar(
                df,
                x="Comparison",
                y="EMD",
                title="Earth Mover's Distance per Comparison",
                text="EMD",
            ),
        )
    )
    figures.append(
        (
            "graph_distance.html",
            px.bar(
                df,
                x="Comparison",
                y="Graph Edit Distance",
                title="Component Distance per Comparison",
                text="Graph Edit Distance",
            ),
        )
    )
    saved_paths = []
    for filename, fig in figures:
        output_path = output_dir / filename
        fig.update_layout(xaxis_tickangle=-25)
        output_path.write_text(fig.to_html(full_html=True, include_plotlyjs="cdn"))
        saved_paths.append(output_path)
    return saved_paths


def create_static_plots(df: pd.DataFrame, output_dir: Path) -> List[Path]:
    if plt is None:
        return []
    metrics = [
        ("KL Divergence", "kl_divergence.png"),
        ("EMD", "emd.png"),
        ("Graph Edit Distance", "graph_distance.png"),
    ]
    saved: List[Path] = []
    for column, filename in metrics:
        fig, ax = plt.subplots(figsize=(6, 4))
        bars = ax.bar(df["Comparison"], df[column], color="#1f77b4")
        ax.set_title(column)
        ax.set_ylabel(column)
        ax.set_xlabel("Comparison")
        ax.tick_params(axis="x", labelrotation=20)
        ax.bar_label(bars, fmt="%.4f", padding=4)
        fig.tight_layout()
        path = output_dir / filename
        fig.savefig(path, dpi=200)
        plt.close(fig)
        saved.append(path)
    return saved


def main() -> None:
    args = parse_args()
    divergence_path = Path(args.divergence_table)
    detailed_path = Path(args.detailed_table)
    output_dir = Path(args.output_dir)
    output_dir.mkdir(parents=True, exist_ok=True)

    divergence_df = load_csv(divergence_path)
    detailed_df = load_csv(detailed_path)
    uncertainty_df = None
    uncertainty_path = Path(args.uncertainty_table)
    if uncertainty_path.exists():
        uncertainty_df = load_csv(uncertainty_path)
    else:
        print(f"[analyze_divergence] bootstrap table not found at {uncertainty_path}, skipping CIs.")

    summary = summarise_divergence(divergence_df)

    markdown = write_markdown(summary, detailed_df, divergence_path, uncertainty_df)
    md_path = output_dir / "divergence_summary.md"
    md_path.write_text(markdown, encoding="utf-8")

    saved_plots: List[Path] = []
    static_plots: List[Path] = []
    if args.plots:
        saved_plots = create_plots(divergence_df, output_dir)
        static_plots = create_static_plots(divergence_df, output_dir)

    print(f"Summary written to {md_path}")
    if saved_plots:
        for path in saved_plots:
            print(f"Plot saved: {path}")
    if static_plots:
        for path in static_plots:
            print(f"Static plot saved: {path}")


if __name__ == "__main__":
    try:
        main()
    except Exception as exc:  # pragma: no cover - provide friendly cli error
        print(f"[analyze_divergence] error: {exc}", file=sys.stderr)
        sys.exit(1)
